## 函数
#### 1、常用库函数
###### 1）常见函数：memset  
![[附件/Pasted image 20241203205648.png]]
* 函数含义：把ptr位置向后的num个字节的内容设置成指定的value值。即填充数组内容。
* 需要引头文件<string.h>
下图为使用例子
![[附件/Pasted image 20241203210017.png]]
#### 2、自定义函数
###### 1）自定义函数基本结构如下图所示
![[自定义函数基本结构.png]]
* 实参：真实传递给函数的参数（常量变量表达式都可以）
* 形参：函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才会被实例化，即分配内存单元。
* 形参当函数调用完成后就自动销毁了，因此形式参数的作用域就是整个函数体
#### 3、传值调用与传址调用
下面举一个基本的swap例子来进行说明
![[附件/Pasted image 20241203211749.png]]
上图为执行swap函数但是是传值调用，那么我们可以看到实参a，b的值确实传过去了，但是实参a、b和形参x，y的地址并不相同。
* 函数调用的时候，实参会传递给形参，函数的形参将会是实参的一份临时拷贝，但是函数形参拥有自己独立的地址空间，所以修改形参不会修改实参。

 ![[附件/Pasted image 20241203212352.png]]
上图为传址调用，这里是将两个标识符的地址传给函数，这样函数可以通过获得的地址，通过解引用操作符可以获得值来进行操作。

问题：什么时候用传值调用，什么时候传地址调用呢？
答：如果在函数体中需要改变传入实参的值，那么就传入的变量的地址；如果只是要用到变量此时的值，那么就传值调用即可。


## 变量的存储类型
存储类型代表编译器为变量分配内存的方式
* 自动变量在动态存储区分配内存
* 静态变量和外部变量是在静态存储区分配内存
* 寄存器变量是在寄存器中分配的
* 动态存储区的变量生存期通常较短，静态存储区的分配内存的变量生存期比较长
#### （一）auto自动变量
* 定义格式：`auto int 变量名`
* ==如果没有指定变量的存储类型，那么其存储类型就缺省为auto==
* 自动变量进入语句块自动申请内存，退出语句块自动释放内存
* 自动变量在定义时不会自动初始化

#### （二）static静态变量
* 定义格式：`static int 变量名`
* 用来修饰局部变量——静态局部变量
* 修饰全局变量——静态全局变量
* 修饰函数——静态函数
###### 1.静态局部变量
* ==静态局部变量在函数结束调用时，系统分配给它的内存并不释放，因为是存储在静态存储区==，即静态变量与程序“共存亡”的
* 以下面这个例子将static静态局部变量
```c
void test() {
	static int a = 1;
	a++;
	printf("%d\n", a);
}

int main() {
	int i = 0;
	while (i < 10) {
		test();
		i++;
	}
	return 0;
}
```
上述代码中，a被static修饰，它是静态变量，静态变量是在静态存储区分配内存的，在一静态存储区分配的内存在程序运行期间不会被释放，所以一旦创建了static静态变量，其生命周期是整个程序运行期间，但是作用域还是对应的{}的内部。
* **所以static修饰局部变量的时候，局部变量出了作用域不销毁的，本质上static修饰局部变量的时候，改变了变量的存储位置**
* **用static修饰，它改变了变量的生命周期，生命周期变长，和程序的生命周期一样**
* 为什么上述代码中函数体每次都会给a进行初始化成1，但是还是会讲a值保留到下一次函数调用
* 答：因为**被static修饰的变量，在编译的时候就已经将变量在静态存储区创建并初始化好了，并且有static修饰的变量的初始化语句是没有对应的汇编语句的，这就说明在编译完成开始执行代码的时候并没有这行这句代码，这句代码已经在编译的时候给其分配了地址，而静态变量的生命周期是整个程序的生命周期，所以它的值可以保存到下一次函数调用。
###### 2.静态全局变量
* 在所有函数外定义的去静态变量，是静态全局变量
![[附件/Pasted image 20241023202025.png]]

###### 3.static修饰函数——静态函数
![[附件/Pasted image 20241023202842.png]]
#### (三)外部变量
* extern修饰外部变量这个具体内容的讲解在[[01数据类型、变量和常量]]
* 外部变量是全局变量
* extern修饰的外部变量是存储的静态存储区的
* 全**局变量和静态变量都存储在静态存储区**，都是在编译的时候就对其分配了地址
* extern只能用于引用其他文件中的非静态全局变量或者函数，但是不能引用静态全局变量和静态函数

#### （四）寄存器变量
* 用register修饰，定义格式：`register int 变量名`
* 寄存器变量是用寄存器存储的变量
* CPU访问内存的操作是很耗时的，使有时对内存的访问无法与指令的执行保持同步，将频繁访问的数据存放在CPU内部的寄存器里，这样CPU对存储器第二遍数据访问，使程序更小更快
* 寄存器的读取速度快，但是内存小造价高。
* 现代编译器能够自动优化程序，将普通变量优化成寄存器变量，并且忽略用户的register指定，所以一般无需特别声明变量为register




